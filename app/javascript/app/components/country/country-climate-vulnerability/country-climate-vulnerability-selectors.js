/* eslint-disable no-confusing-arrow */
import { createSelector } from 'reselect';
import isEmpty from 'lodash/isEmpty';
import groupBy from 'lodash/groupBy';
import sortBy from 'lodash/sortBy';
import pickBy from 'lodash/pickBy';
import qs from 'query-string';
import { lowerUpperFirst } from 'utils';
import { getLabels } from 'components/ndcs/shared/utils';
import { CHART_NAMED_EXTENDED_COLORS } from 'app/styles/constants';

const FEATURE_COUNTRY_CHANGES = process.env.FEATURE_COUNTRY_CHANGES === 'true';

const getIso = state => state.iso || null;
const getAdaptations = state => state.adaptations || null;
const getSearch = state => state.search || null;
const getCountryIndicators = state =>
  state.countryProfileIndicators.data || null;
const getCountries = state => state.countriesData || null;

const getSection = (sections, slug) => sections.find(s => s.slug === slug);

const getDataFromIso = (sections, iso, slug) => {
  const section = getSection(sections, slug);
  if (section && section.values) {
    const isoValue = section.values.find(country => country.location === iso);
    return isoValue ? [{ ...isoValue, id: iso }] : [{ id: iso }];
  }
  return null;
};

export const getMaximumCountries = createSelector([getCountries], countries =>
  countries ? countries.length : null
);

const getCountry = createSelector([getCountries, getIso], (countries, iso) => {
  if (!countries || !iso) return null;
  return countries.find(country => country.iso_code3 === iso);
});

export const getCountryName = createSelector(
  [getCountry],
  country => (country && country.wri_standard_name) || null
);

const getDataFromQuery = (sections, isos, countries, slug) => {
  const section = getSection(sections, slug);
  return (
    section &&
    section.values &&
    isos.map(iso => {
      if (iso) {
        const isoValues = section.values.find(
          country => country.location === iso
        );
        const countryLabel = countries.find(
          country => country.iso_code3 === iso
        );
        return isoValues
          ? { ...isoValues, id: iso, label: countryLabel.wri_standard_name }
          : {
            location: iso,
            value: null,
            id: iso,
            label: countryLabel.wri_standard_name
          };
      }
      return { location: null, value: null, id: Math.random() };
    })
  );
};

const getData = (sections, iso, isos, countries, slug) => {
  if (!isos) {
    return getDataFromIso(sections, iso, slug);
  }
  return getDataFromQuery(sections, isos, countries, slug);
};

const getListDataFromIso = (sections, iso, slug) => {
  const items = sections.filter(section => section.slug.startsWith(slug));
  const itemList = [];
  if (
    !items.some(item => item.values.some(country => country.location === iso))
  ) {
    itemList.push('No data');
  } else {
    items.forEach(item => {
      const countryHasItem = item.values.find(
        country => country.location === iso && country.value === true
      );
      if (countryHasItem) itemList.push({ name: item.name });
    });
  }
  return itemList;
};

const getListDataFromQuery = (sections, isos, slug) => {
  const items = sections.filter(section => section.slug.startsWith(slug));
  const itemList = [];
  isos.forEach((iso, index) => {
    if (
      isos.length === 1 &&
      !items.some(item => item.values.some(country => country.location === iso))
    ) {
      itemList.push('No data');
    } else {
      items.forEach(item => {
        const countryHasItem = item.values.find(
          country => country.location === iso && country.value === true
        );
        if (countryHasItem) {
          itemList.push({ name: item.name, countryIndex: [index] });
        }
      });
    }
  });
  if (itemList[0] !== 'No data') {
    const groupedList = groupBy(itemList, 'name');
    const reducedList = Object.keys(groupedList).reduce(
      (array, key) =>
        array.concat({
          name: key,
          countryIndex: groupedList[key].map(x => x.countryIndex)
        }),
      []
    );
    return reducedList;
  }
  return itemList;
};

const getListData = (sections, iso, isos, slug) => {
  if (!isos) {
    return getListDataFromIso(sections, iso, slug);
  }
  return getListDataFromQuery(sections, isos, slug);
};

const getListMetadata = (sections, iso, slug) => {
  const section = getSection(sections, slug);
  const locationUrl = section.values.find(country => country.location === iso);
  return locationUrl && locationUrl.value;
};

export const getQueryIsos = search => {
  if (!search) return null;
  const query = qs.parse(search);
  if (!query.locations) return null;
  return query.locations.split(',').map(val => {
    if (val) return val;
    return null;
  });
};

export const getHazards = createSelector(
  [getCountryIndicators],
  countryIndicators => {
    if (!countryIndicators || isEmpty(countryIndicators)) return null;
    return pickBy(countryIndicators, i => i.slug.startsWith('hazard'));
  }
);

export const getHazardsLegend = createSelector([getHazards], hazards => {
  if (!hazards) {
    return null;
  }
  const percentage = (value, total) => (value * 100) / total;
  const getValue = key =>
    hazards[key].values &&
    hazards[key].values[0] &&
    +hazards[key].values[0].value;
  const totalValue = Object.keys(hazards).reduce((acc, key) => {
    const value = getValue(key);
    return acc + (value ? +value : 0);
  }, 0);
  const legendItems = Object.keys(hazards)
    .map((key, i) => ({
      id: hazards[key].slug,
      name: hazards[key].name,
      value: Math.round(percentage(getValue(key), totalValue) * 100) / 100,
      color: Object.values(CHART_NAMED_EXTENDED_COLORS)[i]
    }))
    .filter(i => i.value !== 0);

  return legendItems;
});

export const getHazardsChart = createSelector(
  [getHazardsLegend, getHazards],
  (legend, hazards) => {
    if (!legend || !hazards) {
      return null;
    }

    const data = sortBy(
      legend.map(l => ({ name: l.name, value: +l.value })),
      'value'
    ).reverse();
    const config = {
      animation: true,
      innerRadius: 100,
      outerRadius: 120,
      hideLabel: true,
      hideLegend: true,
      innerHoverLabel: true,
      minAngle: 3,
      ...getLabels({ legend })
    };
    return {
      config,
      data
    };
  }
);

export const getSectionData = createSelector(
  [
    getIso,
    getAdaptations,
    getSearch,
    getCountries,
    getCountryIndicators,
    getHazardsChart
  ],
  (iso, adaptations, search, countries, countryIndicators, hazards) => {
    if (!FEATURE_COUNTRY_CHANGES) {
      const queryIsos = getQueryIsos(search);
      const sections = adaptations.data;
      const noCountriesSelected = !iso && !search;

      if (noCountriesSelected || isEmpty(countries) || isEmpty(sections)) {
        return null;
      } // eslint-disable-line no-mixed-operators

      return [
        {
          sectionType: 'CIRCULAR',
          title: getSection(sections, 'poverty_14').name,
          slug: 'poverty_14',
          data: getData(sections, iso, queryIsos, countries, 'poverty_14')
        },
        {
          sectionType: 'LIST',
          title: 'Key hazards',
          slug: 'key_hazard',
          data: getListData(sections, iso, queryIsos, 'hazard'),
          metadataUrl: getListMetadata(sections, iso, 'wb_urls')
        },
        {
          sectionType: 'LINE',
          title: lowerUpperFirst(getSection(sections, 'climate_risks').name),
          subtitle: 'Lower score indicates high levels of climate risk',
          slug: 'climate_risks',
          data: getData(sections, iso, queryIsos, countries, 'climate_risks'),
          maximum: getSection(sections, 'climate_risks').maximum
        },
        {
          sectionType: 'LINE',
          title: getSection(sections, 'vulnerability').name,
          subtitle: 'Lower score indicates less vulnerability',
          slug: 'vulnerability',
          data: getData(sections, iso, queryIsos, countries, 'vulnerability'),
          maximum: getSection(sections, 'vulnerability').maximum
        },
        {
          sectionType: 'LINE',
          title: getSection(sections, 'readiness').name,
          subtitle: 'Higher score indicates high levels of readiness',
          slug: 'readiness',
          data: getData(sections, iso, queryIsos, countries, 'readiness'),
          maximum: getSection(sections, 'readiness').maximum
        },
        {
          sectionType: 'LINK',
          slug: 'link'
        }
      ];
    }

    const hasCountryIndicators = !isEmpty(countryIndicators);

    return {
      snapshots: {
        title: 'NDC-Adaptation Snapshots',
        slug: 'snapshots',
        data: hasCountryIndicators && [
          countryIndicators.ad_fin,
          countryIndicators.ad_included,
          countryIndicators.ad_loss,
          countryIndicators.ad_priority
        ]
      },
      vulnerability: {
        type: 'RANK',
        title: 'NDC-GAIN vulnerability score',
        subtitle: 'Lower score indicates less vulnerability',
        slug: 'vulnerability',
        data: hasCountryIndicators && [
          countryIndicators.vulnerability,
          countryIndicators.vulnerability_rank
        ]
      },
      readiness: {
        type: 'RANK',
        title: 'NDC-GAIN readiness score',
        slug: 'readiness',
        data: hasCountryIndicators && [
          countryIndicators.readiness,
          countryIndicators.readiness_rank
        ]
      },
      hazards: {
        type: 'CHART',
        title: 'Natural Hazard Occurrence',
        slug: 'hazards',
        data: hazards
      }
    };
  }
);

export default {
  getSectionData
};
