/* eslint-disable no-confusing-arrow */
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cx from 'classnames';
import ReactTooltip from 'react-tooltip';
import { COUNTRY_COMPARE_COLORS } from 'data/constants';
import CircularChart from 'components/circular-chart';
import { PieChart } from 'cw-components';
import NoContent from 'components/no-content';
import InfoButton from 'components/button/info-button';
import range from 'lodash/range';
import camelCase from 'lodash/camelCase';

import styles from './vulnerability-graph-styles.scss';

const FEATURE_COUNTRY_CHANGES = process.env.FEATURE_COUNTRY_CHANGES === 'true';

class VulnerabilityGraph extends PureComponent {
  // eslint-disable-line react/prefer-stateless-function

  handleInfoClick = slug => {
    const { setModalMetadata } = this.props;
    setModalMetadata({
      category: 'Country',
      slugs: [slug],
      open: true
    });
  };

  renderCircular() {
    const { sectionData } = this.props;
    const countriesIds = sectionData.data.map(country => country.id);
    const values = sectionData.data.map(country => {
      if (country.location) {
        return country.value ? Math.floor(country.value * 10) / 10 : 'N/A';
      }
      return null;
    });
    const years = sectionData.data.reduce((acc, country) => {
      if (country.location) {
        acc.push(country.year);
      }
      return acc;
    }, []);
    const filteredYears =
      years && years.every(y => y === years[0]) ? [years[0]] : years;
    return values.filter(value => value != null).length > 0 ? (
      <div className={styles.circularChartContainer}>
        {!FEATURE_COUNTRY_CHANGES && (
          <InfoButton
            className={styles.infoBtn}
            infoOpen={false}
            handleInfoClick={() => this.handleInfoClick(sectionData.slug)}
            square
          />
        )}
        {values.map((value, index) =>
          typeof value === 'number' ? (
            <CircularChart
              key={countriesIds[index]}
              index={index}
              value={value}
              color={COUNTRY_COMPARE_COLORS[index]}
            />
          ) : null
        )}
        <div className={styles.circularChartValues}>
          {values.map((value, index) =>
            value !== null ? (
              <div
                key={countriesIds[index]}
                style={{
                  color: COUNTRY_COMPARE_COLORS[index]
                }}
              >
                {typeof value === 'number' ? `${value}%` : 'N/A'}
              </div>
            ) : null
          )}
        </div>
        {filteredYears && (
          <div className={styles.circularChartDates}>
            <span>Data from </span>
            <div className={styles.circularChartDatesYears}>
              {filteredYears.map((year, index) => (
                <span key={countriesIds[index]}>
                  {year && (
                    <span
                      style={{
                        color: COUNTRY_COMPARE_COLORS[index]
                      }}
                    >
                      {year}
                    </span>
                  )}
                  {year && index < filteredYears.length - 1 && <span>, </span>}
                </span>
              ))}
            </div>
          </div>
        )}
      </div>
    ) : (
      <NoContent message={'No data'} className={styles.noContent} />
    );
  }

  renderLine() {
    const { sectionData, inverted } = this.props;
    const values = sectionData.data.map(country => {
      if (country.location) {
        return country.value
          ? (Math.floor(country.value * 100) / 100).toFixed(2)
          : 'N/A';
      }
      return null;
    });
    const countriesRiskValue = sectionData.data.map(country =>
      country.value ? parseInt(country.rank.absolute, 10) * 100 : null
    );
    const maximumCountries = sectionData.maximum;
    const riskAbsoluteValues = countriesRiskValue.map(
      riskValue => riskValue / maximumCountries
    );
    const countriesIds = sectionData.data.map(country => country.id);
    const showTooltip = countriesIds && countriesIds.length > 1;
    const position = inverted ? 'right' : 'left';
    return values.filter(value => value != null).length > 0 ? (
      <div className={styles.lineChartContainer}>
        {!FEATURE_COUNTRY_CHANGES && (
          <InfoButton
            className={styles.infoBtn}
            infoOpen={false}
            handleInfoClick={() => this.handleInfoClick(sectionData.slug)}
          />
        )}
        <div className={styles.riskValue}>
          {values.map((value, index) => (
            <div
              key={countriesIds[index]}
              style={{
                color: COUNTRY_COMPARE_COLORS[index]
              }}
            >
              {value}
            </div>
          ))}
        </div>
        <div className={styles.riskMeter}>
          {values.map((value, index) => {
            const countrySelectedRank = sectionData.data[index].value
              ? sectionData.data[index].rank.absolute
              : '---';
            const countryLabel = sectionData.data[index].label;
            if (riskAbsoluteValues[index] !== 0) {
              return (
                <div
                  key={countriesIds[index]}
                  className={styles.riskMarker}
                  data-for={`${riskAbsoluteValues[index]}`}
                  data-tip={`${countryLabel} ranked ${countrySelectedRank} of  ${maximumCountries} countries`}
                  style={{
                    [position]: `${riskAbsoluteValues[index]}%`,
                    backgroundColor: COUNTRY_COMPARE_COLORS[index]
                  }}
                >
                  {showTooltip && (
                    <ReactTooltip
                      className={styles.tooltip}
                      id={`${riskAbsoluteValues[index]}`}
                    />
                  )}
                </div>
              );
            }
            return null;
          })}
          {sectionData.data.length === 1 && (
            <div className={styles.riskAbsoluteValue}>
              <span className={styles.countriesNumber}>Rank</span>{' '}
              {sectionData.data.map(country =>
                country.value ? country.rank.absolute : '---'
              )}
              <span className={styles.countriesNumber}>
                {' '}
                of {maximumCountries} countries
              </span>
            </div>
          )}
          {range(10).map((_, i) => (
            <div
              key={i} // eslint-disable-line react/no-array-index-key
              className={cx(styles.riskTick, styles[`meter-${i + 1}`])}
            />
          ))}
        </div>
      </div>
    ) : (
      <NoContent className={styles.noContent} message={'No data'} />
    );
  }

  renderList() {
    const { sectionData, countries } = this.props;
    return (
      <div className={styles.listContainer}>
        {!FEATURE_COUNTRY_CHANGES && (
          <InfoButton
            className={styles.infoBtn}
            infoOpen={false}
            handleInfoClick={() => this.handleInfoClick(sectionData.slug)}
          />
        )}
        <div className={styles.list}>
          {sectionData.data.length && sectionData.data[0] !== 'No data' ? (
            sectionData.data.map(hazard => (
              <div key={hazard.name} className={styles.listElementContainer}>
                {hazard.countryIndex && (
                  <div className={styles.listDotsContainer}>
                    {countries.map((country, i) => {
                      let dotColor = '#e6e7ed';
                      /* eslint-disable  no-restricted-syntax */
                      for (const value of hazard.countryIndex) {
                        if (value[0] === i) {
                          dotColor = COUNTRY_COMPARE_COLORS[value[0]];
                          break;
                        }
                      }
                      /* eslint-enable  no-restricted-syntax */
                      const dot = (
                        <span
                          key={Math.random()}
                          style={{ backgroundColor: dotColor }}
                          className={styles.listDots}
                        />
                      );
                      return dot;
                    })}
                  </div>
                )}
                <div className={styles.listText}>{hazard.name}</div>
              </div>
            ))
          ) : (
            <NoContent
              key={'no-data'}
              message={'No data'}
              className={styles.noContent}
            />
          )}
        </div>
        {sectionData.data.length && !sectionData.data[0].countryIndex ? (
          <a
            className={styles.learnMore}
            target={'_blank'}
            href={sectionData.metadataUrl}
          >
            Learn More
          </a>
        ) : null}
      </div>
    );
  }

  renderRank() {
    const { sectionData, maximumCountries } = this.props;
    if (!sectionData || !sectionData.data) return null;

    const [vulnerability, vulnerabilityRank] = sectionData.data;
    const { value } = vulnerability.values[0];
    const { value: rank } = vulnerabilityRank.values[0];

    return (
      <div className={styles.lineChartContainer}>
        <div className={styles.riskValue}>{value}</div>
        <div className={styles.riskMeter}>
          <div className={styles.riskAbsoluteValue}>
            <span className={styles.countriesNumber}>Rank </span>
            {rank}
            <span className={styles.countriesNumber}>
              {' '}
              of {maximumCountries} countries
            </span>
          </div>
          {range(10).map((_, i) => (
            <div
              key={i} // eslint-disable-line react/no-array-index-key
              className={cx(styles.riskTick, styles[`meter-${i + 1}`])}
            />
          ))}
        </div>
      </div>
    );
  }

  renderChart() {
    const { sectionData } = this.props;
    if (!sectionData || !sectionData.data) return null;
    const CustomInnerHoverLabel = ({
      x,
      y,
      value,
      props: {
        payload: { name }
      }
    }) => (
      <text x={x} y={y - 35}>
        <tspan x={x} textAnchor="middle">
          {Math.round(value * 10000) / 100} %
        </tspan>
        <tspan x={x} textAnchor="middle" dy="20">
          Average Annual
        </tspan>
        <tspan x={x} textAnchor="middle" dy="20">
          Hazard Ocurrence
        </tspan>
        <tspan x={x} textAnchor="middle" dy="20">
          of
        </tspan>
        <tspan x={x} textAnchor="middle" dy="20">
          {name}
        </tspan>
      </text>
    );
    const { data, config } = sectionData.data;
    return (
      data && (
        <div className={styles.pieChart}>
          <PieChart
            data={data}
            width={350}
            config={config}
            customTooltip={<div style={{ display: 'none' }} />}
            customInnerHoverLabel={CustomInnerHoverLabel}
            theme={{ pieChart: styles.pieChart }}
          />
          <div className={styles.pieLegend}>
            {data.map(d => {
              const theme = config.theme[camelCase(d.name)];
              return (
                <div className={styles.legendItem}>
                  <span
                    className={styles.dot}
                    style={{ backgroundColor: theme.stroke }}
                  />
                  <span className={styles.percentage}>{d.value} %</span>
                  <span className={styles.label}>{theme.label}</span>
                </div>
              );
            })}
          </div>
        </div>
      )
    );
  }

  render() {
    const { sectionData, type } = this.props;
    if (FEATURE_COUNTRY_CHANGES) {
      switch (type) {
        case 'RANK':
          return this.renderRank();
        case 'CHART':
          return this.renderChart();
        default:
          return null;
      }
    }

    switch (sectionData.sectionType) {
      case 'CIRCULAR':
        return this.renderCircular();
      case 'LINE':
        return this.renderLine();
      case 'LIST':
        return this.renderList();
      default:
        return null;
    }
  }
}

VulnerabilityGraph.propTypes = {
  sectionData: PropTypes.object,
  setModalMetadata: PropTypes.func.isRequired,
  inverted: PropTypes.bool.isRequired,
  type: PropTypes.string,
  countries: PropTypes.array,
  maximumCountries: PropTypes.number
};

VulnerabilityGraph.defaultProps = {
  inverted: false
};

export default VulnerabilityGraph;
